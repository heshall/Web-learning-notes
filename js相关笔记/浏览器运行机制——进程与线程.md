## 浏览器的运行机制

- ### 进程和线程

  - **进程与线程区别**：

    **进程**是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）

    **线程**是cpu调度的最小单位（线程是建立在进程之上一次程序运行单位，一个进程可有多个线程）

    PS：**单线程与多线程**，都是指**一个进程**中的单和多


- **浏览器多进程**：

  系统给进程分配了资源（cpu，内存）

  1. **Browser进程**：浏览器的主进程（负责协调、主控），只有一个
  2. **第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建
  3. **GPU进程**：最多一个，用于3D绘制等
  4. **浏览器渲染进程**：（浏览器内核）（**Renderer**进程，内部是多线程的），用作页面渲染，js执行等

  ​

## 浏览器渲染进程

前端主要用到的进程，页面渲染，js执行，事件循环等

1. **GUI渲染线程**：
   - 负责渲染浏览器界面，解析HTML,CSS构建DOM树和RenderObject树，布局和绘制等。
   - 当界面需要重绘或回流，会触发该线程
   - **GUI渲染线程与JS引擎线程是互斥的**，当js引擎执行时GUI线程就会被挂起，GUI更新会保存在一个队列中等**js引擎空闲时**执行
2. **JS引擎线程**：
   - js内核，处理执行js脚本程序（v8）
   - **只会有一个js执行线程**，等待任务队列中任务到来，加以处理
   - **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. **事件触发线程**
   - 归属于浏览器而不是JS引擎，用来控制事件轮询，**js例外开启线程辅助js引擎线程**（异步）
   - 当js引擎执行脚本中有事件，就会将它添加到事件触发线程中
   - 当事件线程中的事件被触发时，线程就会把事件添加到**js引擎线程任务队列的队尾中**，等待js引擎**空闲时**，去执行队列中的任务
4. **定时器触发线程**
   - `setInternal`与`setTimeout`所在线程
   - 浏览器另开一条线程计时，与事件触发线程类似，计时完毕后添加到**js引擎线程任务队列的队尾**，等js引擎空闲时执行
   - 所以计时的时间是把执行任务放到任务队列中的时间，并不一定是任务执行时间（有误差），是任务执行最快时间，w3c标准规定setTimeout最少计时时间为4ms，**小于取4ms**
5. **HTTP异步请求线程**
   - 去发送http请求，，检测到状态变更时，如果有回到函数就会**产生状态变更事件**，放到js引擎**任务队列**中，等待js引擎空闲去执行
     ​

## Event Loop 事件循环

![](D:\实验室学习\学习笔记\Typora\assets/事件循环-1524402072198.png)

### 运行流程：

- js分为**同步任务**与**异步任务**
- 当js脚本被执行时，从上到下执行，普通的同步任务直接在js引擎主线程执行 形成一个**执行栈**
- 执行到异步任务时（如事件，定时器，http请求）把**事件**放到浏览器提供的另外几个事件触发线程上执行
- **任务队列：** 当另外的事件触发线程中有事件达到了执行条件，就把该事件放到任务队列的**队尾**
- 当执行栈中的同步任务全部执行完毕后（js引擎线程空闲时），js引擎就会读取任务队列，如果队列中有事件就把任务队列中**第一个**事件关联的回调函数放到js执行栈中执行

流程图如下

![事件循环流程图](D:\实验室学习\学习笔记\Typora\assets/事件循环流程-1524403197455.png)



## **定时器 setTimeout , setInterval**

- 与事件没什么区别，当js引擎线程执行到定时器时，就把该任务放到计时器线程中计时
- 当计时完毕后就把事件放到任务队列中，等待js主线程空闲时读取任务队列再执行该回调函数
- 在计时完毕后只是把事件推入任务队列中，**所以计时器的计时并不一定是准确的** 
- PS：在**W3C标准**中规定最小的计时时间为4ms，如果设置的事件小与4ms会按4ms执行

## setTimeout 而不是 setInterval

- setInterval是每次都精确的隔一段时间推入一个事件 **但是事件的执行也需要时间，有可能上一个事件还没执行完，下一个事件已经计时完毕，会造成连续执行该事件的累积效应**

- **setTimeout 模拟 setInterval**

  用setTimeout就会在事件执行完毕后再把下一次定时器放到事件触发线程里，所以执行的事件间隔不会小于设置的时间

  ```javascript
  (function mocking () {
    setTimeout(function() {
     	console.log('1');
      mocking();
      //setTimeout(arguments.callee,500); 
    }, 500)
  })()
  ```

  ​

  ​

  ​

  ​





